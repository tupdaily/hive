/**
 * This file was auto-generated by Fern from our API Definition.
 */
import * as environments from "../../../../environments";
import * as core from "../../../../core";
import * as Letta from "../../../index";
export declare namespace Tools {
    interface Options {
        environment?: core.Supplier<environments.LettaEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        token?: core.Supplier<string | undefined>;
        /** Override the X-Project header */
        project?: core.Supplier<string | undefined>;
        fetcher?: core.FetchFunction;
    }
    interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Override the X-Project header */
        project?: string | undefined;
        /** Additional headers to include in the request. */
        headers?: Record<string, string>;
    }
}
export declare class Tools {
    protected readonly _options: Tools.Options;
    constructor(_options?: Tools.Options);
    /**
     * Get a tool by ID
     *
     * @param {string} toolId - The ID of the tool in the format 'tool-<uuid4>'
     * @param {Tools.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.UnprocessableEntityError}
     *
     * @example
     *     await client.tools.retrieve("tool-123e4567-e89b-42d3-8456-426614174000")
     */
    retrieve(toolId: string, requestOptions?: Tools.RequestOptions): core.HttpResponsePromise<Letta.Tool>;
    private __retrieve;
    /**
     * Delete a tool by name
     *
     * @param {string} toolId - The ID of the tool in the format 'tool-<uuid4>'
     * @param {Tools.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.UnprocessableEntityError}
     *
     * @example
     *     await client.tools.delete("tool-123e4567-e89b-42d3-8456-426614174000")
     */
    delete(toolId: string, requestOptions?: Tools.RequestOptions): core.HttpResponsePromise<unknown>;
    private __delete;
    /**
     * Update an existing tool
     *
     * @param {string} toolId - The ID of the tool in the format 'tool-<uuid4>'
     * @param {Letta.ToolUpdate} request
     * @param {Tools.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.UnprocessableEntityError}
     *
     * @example
     *     await client.tools.modify("tool-123e4567-e89b-42d3-8456-426614174000")
     */
    modify(toolId: string, request?: Letta.ToolUpdate, requestOptions?: Tools.RequestOptions): core.HttpResponsePromise<Letta.Tool>;
    private __modify;
    /**
     * Get a count of all tools available to agents belonging to the org of the user.
     *
     * @param {Letta.ToolsCountRequest} request
     * @param {Tools.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.UnprocessableEntityError}
     *
     * @example
     *     await client.tools.count({
     *         name: "name",
     *         search: "search",
     *         returnOnlyLettaTools: true,
     *         excludeLettaTools: true
     *     })
     */
    count(request?: Letta.ToolsCountRequest, requestOptions?: Tools.RequestOptions): core.HttpResponsePromise<number>;
    private __count;
    /**
     * Get a list of all tools available to agents.
     *
     * @param {Letta.ToolsListRequest} request
     * @param {Tools.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.UnprocessableEntityError}
     *
     * @example
     *     await client.tools.list({
     *         before: "before",
     *         after: "after",
     *         limit: 1,
     *         order: "asc",
     *         orderBy: "created_at",
     *         name: "name",
     *         search: "search",
     *         returnOnlyLettaTools: true
     *     })
     */
    list(request?: Letta.ToolsListRequest, requestOptions?: Tools.RequestOptions): core.HttpResponsePromise<Letta.Tool[]>;
    private __list;
    /**
     * Create a new tool
     *
     * @param {Letta.ToolCreate} request
     * @param {Tools.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.UnprocessableEntityError}
     *
     * @example
     *     await client.tools.create({
     *         sourceCode: "source_code"
     *     })
     */
    create(request: Letta.ToolCreate, requestOptions?: Tools.RequestOptions): core.HttpResponsePromise<Letta.Tool>;
    private __create;
    /**
     * Create or update a tool
     *
     * @param {Letta.ToolCreate} request
     * @param {Tools.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.UnprocessableEntityError}
     *
     * @example
     *     await client.tools.upsert({
     *         sourceCode: "source_code"
     *     })
     */
    upsert(request: Letta.ToolCreate, requestOptions?: Tools.RequestOptions): core.HttpResponsePromise<Letta.Tool>;
    private __upsert;
    /**
     * Upsert base tools
     *
     * @param {Tools.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.UnprocessableEntityError}
     *
     * @example
     *     await client.tools.upsertBaseTools()
     */
    upsertBaseTools(requestOptions?: Tools.RequestOptions): core.HttpResponsePromise<Letta.Tool[]>;
    private __upsertBaseTools;
    /**
     * Attempt to build a tool from source, then run it on the provided arguments
     *
     * @param {Letta.ToolRunFromSource} request
     * @param {Tools.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.UnprocessableEntityError}
     *
     * @example
     *     await client.tools.runToolFromSource({
     *         sourceCode: "source_code",
     *         args: {
     *             "key": "value"
     *         }
     *     })
     */
    runToolFromSource(request: Letta.ToolRunFromSource, requestOptions?: Tools.RequestOptions): core.HttpResponsePromise<Letta.ToolReturnMessage>;
    private __runToolFromSource;
    /**
     * Get a list of all configured MCP servers
     *
     * @param {Tools.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.UnprocessableEntityError}
     *
     * @example
     *     await client.tools.listMcpServers()
     */
    listMcpServers(requestOptions?: Tools.RequestOptions): core.HttpResponsePromise<Record<string, Letta.ListMcpServersResponseValue>>;
    private __listMcpServers;
    /**
     * Add a new MCP server to the Letta MCP server config
     *
     * @param {Letta.AddMcpServerRequest} request
     * @param {Tools.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.UnprocessableEntityError}
     *
     * @example
     *     await client.tools.addMcpServer({
     *         serverName: "server_name",
     *         command: "command",
     *         args: ["args"]
     *     })
     */
    addMcpServer(request: Letta.AddMcpServerRequest, requestOptions?: Tools.RequestOptions): core.HttpResponsePromise<Letta.AddMcpServerResponseItem[]>;
    private __addMcpServer;
    /**
     * Get a list of all tools for a specific MCP server
     *
     * @param {string} mcpServerName
     * @param {Tools.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.UnprocessableEntityError}
     *
     * @example
     *     await client.tools.listMcpToolsByServer("mcp_server_name")
     */
    listMcpToolsByServer(mcpServerName: string, requestOptions?: Tools.RequestOptions): core.HttpResponsePromise<Letta.McpTool[]>;
    private __listMcpToolsByServer;
    /**
     * Register a new MCP tool as a Letta server by MCP server + tool name
     *
     * @param {string} mcpServerName
     * @param {string} mcpToolName
     * @param {Tools.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.UnprocessableEntityError}
     *
     * @example
     *     await client.tools.addMcpTool("mcp_server_name", "mcp_tool_name")
     */
    addMcpTool(mcpServerName: string, mcpToolName: string, requestOptions?: Tools.RequestOptions): core.HttpResponsePromise<Letta.Tool>;
    private __addMcpTool;
    /**
     * Delete a MCP server configuration
     *
     * @param {string} mcpServerName
     * @param {Tools.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.UnprocessableEntityError}
     *
     * @example
     *     await client.tools.deleteMcpServer("mcp_server_name")
     */
    deleteMcpServer(mcpServerName: string, requestOptions?: Tools.RequestOptions): core.HttpResponsePromise<Letta.DeleteMcpServerResponseItem[]>;
    private __deleteMcpServer;
    /**
     * Update an existing MCP server configuration
     *
     * @param {string} mcpServerName
     * @param {Letta.UpdateMcpServerRequest} request
     * @param {Tools.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.UnprocessableEntityError}
     *
     * @example
     *     await client.tools.updateMcpServer("mcp_server_name", {})
     */
    updateMcpServer(mcpServerName: string, request: Letta.UpdateMcpServerRequest, requestOptions?: Tools.RequestOptions): core.HttpResponsePromise<Letta.UpdateMcpServerResponse>;
    private __updateMcpServer;
    /**
     * Test connection to an MCP server without adding it.
     * Returns the list of available tools if successful.
     *
     * @param {Letta.TestMcpServerRequest} request
     * @param {Tools.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Letta.UnprocessableEntityError}
     *
     * @example
     *     await client.tools.testMcpServer({
     *         serverName: "server_name",
     *         command: "command",
     *         args: ["args"]
     *     })
     */
    testMcpServer(request: Letta.TestMcpServerRequest, requestOptions?: Tools.RequestOptions): core.HttpResponsePromise<unknown>;
    private __testMcpServer;
    /**
     * Connect to an MCP server with support for OAuth via SSE.
     * Returns a stream of events handling authorization state and exchange if OAuth is required.
     */
    connectMcpServer(request: Letta.ConnectMcpServerRequest, requestOptions?: Tools.RequestOptions): core.HttpResponsePromise<core.Stream<Letta.StreamingResponse>>;
    private __connectMcpServer;
    protected _getCustomAuthorizationHeaders(): Promise<{
        Authorization: string;
    }>;
}
